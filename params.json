{"name":"Phinject","tagline":"PHP Dependency Injection Library","body":"Phinject\r\n========\r\n   \r\n[![Build Status](https://travis-ci.org/aztech-digital/phinject.png?branch=master)](https://travis-ci.org/aztech-digital/phinject)\r\n[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/aztech-digital/phinject/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/aztech-digital/phinject/?branch=master)\r\n[![Code Coverage](https://scrutinizer-ci.com/g/aztech-digital/phinject/badges/coverage.png?b=master)](https://scrutinizer-ci.com/g/aztech-digital/phinject/?branch=master)\r\n[![HHVM Status](http://hhvm.h4cc.de/badge/aztech/phinject.png)](http://hhvm.h4cc.de/package/aztech/phinject)\r\n\r\nPhinject is a simple dependency injection container, with extensible activation & injection strategies.\r\n\r\n\r\n## Setup\r\n\r\nThe recommended setup is to create a configuration folder at the root of your repository. All configuration is based on YAML files. JSON and native PHP files are also supported using the same data structure.\r\n\r\nSample YAML file :\r\n\r\n```\r\nparameters:\r\n    MyParameter: 'Some parameter value'\r\n    MyOtherParameter: 42\r\n    MyParameters:\r\n        nested_level:\r\n            foo: foo\r\n            bar: bar\r\n            baz: foobar\r\n        late_bound:\r\n            # This will inject the value of MyOtherParameter (42 in this case)\r\n            param_foo: %MyOtherParameter\r\n            # This will inject the value of environment variable FOO\r\n            env_foo: $env.FOO\r\n            const_baz: $const.BAZ\r\n\t\tcoerce_string_value:\r\n\t\t\t# This will inject \"$env.FOO\" instead of the value of FOO environment variable.\r\n\t\t\tforced_var: \\$env.FOO\r\nclasses:\r\n    MyServiceName:\r\n        class: \\Fully\\Qualified\\ClassName\r\n        arguments: [ @MyDependency, %MyParameter, %MyParameters.nested_level, 'Hard-coded value', $container, $env.ENV, $const.ROOT_PATH ]\r\n    MyOtherServiceWithSingleArgument:\r\n    \tclass: \\Fully\\Qualified\\ClassName\r\n    \targuments: @MyDependency\r\n    MyDependency:\r\n        class: \\Fully\\Qualified\\DependencyClassName\r\n        props:\r\n            MyProperty: %MyOtherParameter\r\n    DependencyBuildFromStaticMethodCall:\r\n\t\tbuilder:  \\Fully\\Qualified\\BuilderClassName::buildMethod(@MethodArgument, %param.value)\r\n    DependencyBuildFromInstanceMethodCall:\r\n\t\tbuilder:  MyDependency->buildMethod(@MethodArgument, %param.value)\r\n```\r\n\r\nBootstrapping the container and fetching an object :\r\n\r\n```\r\n$container = Aztech\\Phinject\\ContainerFactory::createFromYaml('config/dependencies.yml');\r\n$service = $container->get('MyServiceName');\r\n\r\n// Do stuff with your service ...\r\n\r\n```\r\n\r\n## References\r\n\r\nYou can inject different kind of references inside class definitions. You can get other service instances, parameters, the container itself, env variables, and constant values.\r\n\r\n### Named references\r\n- @ServiceName : fetch an instance of that definition\r\n- %param : fetch a parameter defined in the container\r\n- $container : fetch the container itself\r\n- $env.ENV_NAME : fetch an environment variable. Allowed as a parameter value.\r\n- $const.CONST_NAME : fetch a global defined constant value. Allowed as a parameter value.\r\n\r\n### Anonymous references\r\n\r\nDependencies can also be expressed as anonymous dependencies. This avoids binding a dependency to the container, and can be useful to omit certain dependencies from being accessible via the container.\r\n\r\nSo the following definitions :\r\n\r\n```\r\nclasses:\r\n    MyDependency:\r\n        class: \\My\\Dependency\r\n        call: \r\n            someMethod: [ \"arg\" ]\r\n    MyService:\r\n        class: \\My\\Class\r\n        args:\r\n            [ @MyDependency ]\r\n...\r\n```\r\n\r\nCan now be rewritten as :\r\n\r\n```\r\nclasses:\r\n    MyService:\r\n        class: \\My\\Class\r\n        args:\r\n            - class: \\My\\Dependency\r\n              isClass: true\r\n              call: \r\n                  someMethod: [ \"arg\" ]\r\n...\r\n```\r\n\r\nWhile not strictly mandatory, it is recommended to include the `isClass` parameter in anonymous definitions. Without that extra key, the dependency resolver is unable to determine what causes the definition to fail building, and automatically falls back to returning the definition as a parameter array, which can cause misleading error messages.\r\n\r\n## Semi-automatic injections\r\n\r\nIf you find yourself calling the same method on multiple classes that share a common interface or base class, you can define global method injections that will apply to all types deriving from the base type defined in your global injection :\r\n\r\n```\r\nglobal:\r\n    injections:\r\n        \"\\Psr\\Log\\LoggerAwareInterface\":\r\n            setLogger: [ @Logger ]\r\nclasses:\r\n    Logger: \r\n        class: \\Psr\\Log\\NullLogger\r\n    MyService:\r\n        class: \\My\\ServiceImplementingLoggerAwareInterface\r\n```\r\n\r\nWhenever 'MyService' is instantiated, it's `setLogger` method will be invoked since it implements `LoggerAwareInterface`.\r\n\r\n## Template pre-processor.\r\naztech-dev/dic-it\r\nTo help maintain configuration files, DIC-IT provides a lightweight configuration preprocessor which can be used to define templates when you have to initialize multiple objects graphs that share the same build pattern. At the time being, only full service definition templates are supported.\r\n\r\nA sample template definition and use follows :\r\n\r\n```\r\ntemplates:\r\n    MyTemplate: \r\n        class: \"{{template-class-var}}\"\r\n        args:\r\n            - \"{{template-ctor-var}}\"    \r\n    \r\napply-templates:\r\n    TemplatedService:\r\n        template: MyTemplate\r\n        apply:\r\n            template-class-var: \"\\\\MyTemplate\\\\Class\"     \r\n            template-ctor-var: \"Some arg value\"\r\n```\r\n\r\nThis example will declare an object definition named \"TemplatedService\" and register it in the container.\r\n\r\nNote that templated definitions cannot be bound to the container manually, they have to be processed into actual object definitions first.\r\n\r\n## Using includes\r\n\r\nThe configuration can be split into multiple files to ease management of your dependencies :\r\n\r\n```\r\nincludes:\r\n    - relative/file.yml\r\n    - relative/another-file.yml\r\n    \r\nclasses:\r\n    ...\r\n```\r\n\r\nThis allows you to separate parameters from service definitions for example.\r\n\r\n## Default object life-cycle\r\n\r\nBy default, all objects are created as non-singleton (this will definitely change) objects, so every time a reference is resolved by the container, a new instance of the requested object is created.\r\n\r\n## Managing circular dependencies\r\n\r\nBy default, circular dependencies are not handled well (stack overflow...) due the default object life-cycle. To enable circular dependencies for a given object, at least one of the two objects must be defined as a singleton. This however will not yield the expected results, so it is *highly* recommended to define both objects involved in the circular dependency as singletons.\r\n\r\n## Credits\r\n\r\nThis library is originally a fork on `oliviermadre/dic-it`, available [here](https://github.com/oliviermadre/dic-it).\r\n\r\nMost of the core features have however been refactored or rewritten, enough that I felt it was time to re-brand this package, in order to both prevent confusion with the original package, and because I did not like the name.\r\n","google":"UA-53268623-7","note":"Don't delete this file! It's used internally to help with page regeneration."}